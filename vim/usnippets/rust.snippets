snippet /^ *da(te)?/ "Date" rb
// `date-utc`
$0
endsnippet

snippet /use|u/ "use" br
use ${2:std::${1:env}};
endsnippet

snippet e "e" b
extern crate ${1:walkdir};
endsnippet

snippet /(\s+)p/ "println" ir
`!p snip.rv = match.group(1)`println!(${4:"$2{}$3", ${1:args}});$0
endsnippet

snippet /(\s+)d/ "debug println" ir
`!p snip.rv = match.group(1)`println!("$2{${3::?}}", ${1:args});$0
endsnippet

snippet .ex "expect" i
.expect("$1");$0
endsnippet

snippet loop "loop" b
loop {
	${VISUAL}$0
}
endsnippet

snippet match "match" i
match ${1:${VISUAL}} {
	Some(${2:arg}) => $2,
	None => return Err("${3:$2 absent from $1}"),
}
endsnippet

snippet /\.une|\.uoe|\.ue/ "unwrap or else" r
.unwrap_or_else(|err| {
	eprintln!("Failed$1: {}", err);
	process::exit(1);
});
endsnippet

snippet /\.unw|\.un|\.u/ ".unwrap" r
.unwrap()
endsnippet

snippet { "{" i
{
	${VISUAL}$0
}
endsnippet

snippet fmt "format" i
format!(${VISUAL}$2, ${1:contents})
endsnippet

snippet Ok "Ok" b
Ok(num) => num,
Err(_) => continue,
endsnippet

snippet mod "mod" b
mod ${1:network} {
	${VISUAL}$0
}
endsnippet

snippet main "main" b
fn main() {
	${VISUAL}${0:println!("Hello, world!");}
}
endsnippet

snippet f "fn" b
fn ${1:parse_config}(${2:args: &[String]}) ${3:-> ${4:&str}$5} {
	${VISUAL}${0:unimplemented!()}
}
endsnippet

snippet pf "pub fn" b
pub fn ${1:parse_config}(${2:args: &[String]}) ${3:-> ${4:&str}$5} {
	${VISUAL}${0:unimplemented!()}
}
endsnippet

snippet (l "lambda" i
(|x| x$1
endsnippet

snippet le "let" b
let ${1:query} = ${2:&args[${3:1}]};
endsnippet

snippet lm "let mut" b
let mut ${1:file} = ${2:File::open("${3:hello.html}").unwrap()};
endsnippet

snippet ifl "if let" b
if let Some(${1:thread}) = ${3:${2:worker.thread}.take()} {
	${4:thread.join().unwrap()};
}
endsnippet

snippet s "struct" b
struct ${1:Config} {
	${2:query}: ${3:String},$0
}
endsnippet

snippet ps "pub struct" b
pub struct ${1:Config} {
	${2:query}: ${3:String},$0
}
endsnippet

snippet enum "enum" b
enum ${1:Message} {
	NewJob(Job),
	Terminate,
}
endsnippet

snippet /impl|i/ "impl" rb
impl ${1:Config} {
	${VISUAL}$0
}
endsnippet

snippet m "method" b
pub fn ${1:run}(&self$2)$3 {
	${0:unimplemented!()}
}
endsnippet

snippet new "new" b
pub fn new(${1:id: i32}) -> ${2:Worker} {
	$2$0
}
endsnippet

snippet tr "trait" b
pub trait ${1:Draw} {
	fn ${1/\w+/\L$0\E/}(&self);
}
endsnippet

snippet if "if" b
if ${1:args.len() < 3} {
	${VISUAL}${0:unimplemented!()}
}
endsnippet

snippet }e "else" b
} else {
	${0:unimplemented!()}
}
endsnippet

snippet for "for" b
for ${1:line} in ${2:contents.lines()} {
	${0:unimplemented!()}
}
endsnippet

snippet r "r" b
return ${1:Err("${2:not enough arguments}")};
endsnippet

snippet ex "process.exit" b
process::exit(1);
endsnippet

snippet /vec|ve/ "Vec" ir
Vec<${VISUAL}$1>
endsnippet

snippet bo "Box" i
Box<${VISUAL}$1>
endsnippet

snippet res "Result" i
Result<${VISUAL}$1, io::Error>
endsnippet

snippet opt "Option" i
Option<${VISUAL}$1>
endsnippet

# Tests

snippet test "test module" b
#[cfg(test)]
mod test {
	extern crate spectral;
	use self::spectral::prelude::*;
	use super::*;

	$0
}
endsnippet

snippet t "t" b
#[test]
fn ${1:simplest_case}() {
	$0
}
endsnippet

snippet as "assert!" b
assert!(${1:x}, "${2:$1 wasn't true}");
endsnippet

snippet ae "assert_eq!" b
assert_eq!(${1:left}, ${2:right});
endsnippet
