# ||
# || Date
# ||

snippet /^ *da(te)?/ "Date" rb
// `date-utc`
$0
endsnippet

# ||
# || Comments
# ||

snippet / "/" w
// ${VISUAL}$0
endsnippet

snippet T "TODO (todo)" !
// TODO: ${1}
endsnippet

# ||
# || Basement
# ||

priority -1

# See UltiSnips-custom-context-snippets
snippet /^$/ "basement-implicit" "snip.line > 0 and re.match('^$', snip.buffer[snip.line-1])" re
/+
${VISUAL}$0
+/
endsnippet

priority 0

# ||
# || Modules
# ||

snippet i "import (imp)" b
import ${0:std.stdio};
endsnippet

snippet pi "public import" b
public import ${0:/*module*/};
endsnippet

# ||
# || Functions
# ||

snippet r "return" w
return ${0:/*value to return*/};
endsnippet

# ||
# || Values
# ||

snippet a "auto" b
auto ${1:/*variable*/} = ${0:/*value*/};
endsnippet

snippet c "const" b
const ${1:/*variable*/} = ${0:/*value*/};
endsnippet

snippet siz "size_t" b
size_t ${1:/*variable*/} = ${0:/*value*/};
endsnippet

# ||
# || Conditionals
# ||

snippet if "if" b
if (${1:/*condition*/}) {
    ${VISUAL}$0
}
endsnippet

snippet ife "if else" b
if (${1:/*condition*/}) {
    ${2:/*code*/}
} else {
    ${0:/*else*/}
}
endsnippet

snippet /\b(else|els|el)/ "else (el)" wr
else {
    ${VISUAL}$0
}
endsnippet

snippet elif "else if" w
else if(${1:/*condition*/}) {
    ${VISUAL}$0
}
endsnippet

snippet sw "switch"
switch(${1:/*var*/})
{
    case ${2:/*value*/}:
        ${3:/*code*/}
        break;
    default:
        ${0:assert(false);}
}
endsnippet

snippet case "case" b
case ${1:/*value*/}:
    ${0:/*code*/}
    break;
endsnippet

# ||
# || Loops
# ||

snippet do "do while" b
do {
    ${VISUAL}$0
} while(${1:/*condition*/});
endsnippet

snippet wh "while" b
while(${1:/*condition*/})
{
    ${VISUAL}$0
}
endsnippet

snippet for "for" b
for (${4:size_t} ${2:i} = 0; $2 < ${1:count}; ${3:++$2})
{
    ${VISUAL}$0
}
endsnippet

snippet for; "for(;;)" b
for(;;)
{
    ${VISUAL}$0
}
endsnippet

snippet /\b(foreach|fore)/ "foreach" wr
foreach(${1:/*elem*/}; ${2:/*range*/})
{
    ${VISUAL}$0
}
endsnippet

snippet forif "foreach if (forif)" b
foreach(${1:/*elem*/}; ${2:/*range*/}) if(${3:/*condition*/})
{
    ${VISUAL}$0
}
endsnippet

# ||
# || Contracts
# ||

snippet in "in contract" b
in
{
    assert(${1:/*condition*/}, "${2:error message}");
    $0
}
body
endsnippet

snippet out "out contract (out)" b
out${1:(result)}
{
    assert(${2:/*condition*/}, "${3:error message}");
    $0
}
body
endsnippet

snippet inv "invariant (inv)" b
invariant()
{
    assert(${1:/*condition*/}, "${2:error message}");
    $0
}
endsnippet

# ||
# || Unsorted
# ||

# Functions (generic)

snippet f "function definition (fun)"
${1:void} ${2:/*function name*/}(${3:/*args*/}) ${4:@safe pure nothrow} {
    ${VISUAL}${5:/*code*/}
}
endsnippet

snippet void "void function definition (void)"
void ${1:/*function name*/}(${2:/*args*/}) ${3:@safe pure nothrow}
{
    ${VISUAL}${4:/*code*/}
}
endsnippet

snippet this "ctor (this)" w
this(${1:/*args*/})
{
    ${VISUAL}${2:/*code*/}
}
endsnippet

snippet get "getter property (get)" !
@property ${1:/*type*/} ${2:/*member_name*/}() const pure nothrow {return ${3:$2_};}
endsnippet

snippet set "setter property (set)" !
@property void ${1:/*member_name*/}(${2:/*type*/} rhs) pure nothrow {${3:$1_} = rhs;}
endsnippet

# Functions (concrete)

snippet main "Main" b
void main(string[] args) @safe {
	args = args[1 .. $];

	${VISUAL}${0: /*code*/}
}
endsnippet

# Mixins

snippet signal "signal (signal)" b
mixin Signal!(${1:/*args*/}) ${2:/*name*/};
endsnippet

# Scope

snippet scope "scope (scope)" b
scope(${1:exit})
{
    ${VISUAL}${2:/*code*/}
}
endsnippet

# With

snippet with "with (with)"
with(${1})
{
    ${VISUAL}${2:/*code*/}
}
endsnippet

# Exception handling

snippet try "try/catch (try)" b
try
{
    ${VISUAL}${1:/*code to try*/}
}
catch(${2}Exception e)
{
    ${3:/*handle exception*/}
}
endsnippet

snippet tryf "try/catch/finally (tryf)" b
try
{
    ${VISUAL}${1:/*code to try*/}
}
catch(${2}Exception e)
{
    ${3:/*handle exception*/}
}
finally
{
    ${4:/*cleanup*/}
}
endsnippet

snippet catch "catch (catch)" b
catch(${1}Exception e)
{
    ${2:/*handle exception*/}
}
endsnippet

snippet thr "throw (thr)"
throw new ${1}Exception("${2}");
endsnippet


# Type declarations

snippet struct "struct (struct)"
struct ${1:`!p snip.rv = (snip.basename or "name")`}
{
    ${2}
}
endsnippet

snippet union "union (union)"
union ${1:`!p snip.rv = (snip.basename or "name")`}
{
    ${2}
}
endsnippet

snippet class "class (class)"
class ${1:`!p snip.rv = (snip.basename or "name")`}
{
    ${2}
}
endsnippet

snippet inter "interface (inter)"
interface ${1:`!p snip.rv = (snip.basename or "name")`}
{
    ${2}
}
endsnippet

snippet enum "enum (enum)"
enum ${1:`!p snip.rv = (snip.basename or "name")`}
{
    ${2}
}
endsnippet


# Exception declarations

snippet exc "exception declaration (exc)" b
/// ${3:/*documentation*/}
class ${1}Exception : ${2}Exception 
{
    public this(string msg, string file = __FILE__, int line = __LINE__)
    {
        super(msg, file, line);
    }
}
endsnippet


# Conditional compilation

snippet version "version (version)" b
version(${1:/*version name*/})
{
    ${VISUAL}${2:/*code*/}
}
endsnippet

snippet debug "debug" b
debug
{
    ${VISUAL}${1:/*code*/}
}
endsnippet


# Templates

snippet temp "template (temp)" b
template ${2:/*name*/}(${1:/*args*/})
{
    ${3:/*code*/}
}
endsnippet


# Asserts

snippet ass "assert (ass)" b
assert(${1:false}, "${2:TODO}");

endsnippet


# Unittests

snippet unittest "unittest (unittest)" b
unittest
{
    ${1:/*code*/}
}
endsnippet


# Common member functions

snippet opDis "opDispatch (opDis)" b
${1:/*return type*/} opDispatch(string s)()
{
    ${2:/*code*/};
}
endsnippet

snippet op= "opAssign (op=)" b
void opAssign(${1} rhs) ${2:@safe pure nothrow}
{
    ${2:/*code*/}
}
endsnippet

snippet opCmp "opCmp (opCmp)" b
int opCmp(${1} rhs) @safe const pure nothrow
{
    ${2:/*code*/}
}
endsnippet

snippet opApply "opApply (opApply)" b
int opApply(int delegate(ref ${1:/*iterated type/s*/}) dg)
{
    int result = 0;
    ${2:/*loop*/}
    {
        result = dg(${3:/*arg/s*/});
        if(result){break;}
    }
    return result;
}
endsnippet

snippet toString "toString (toString)" b
string toString() @safe const pure nothrow
{
    ${1:/*code*/}
}
endsnippet




# DDoc

snippet doc "generic ddoc block (doc)" b
/// ${1:description}
///
/// ${2:details}
endsnippet

snippet fdoc "function ddoc block (fdoc)" b
/// ${1:description}
///
/// ${2:Params:  ${3:param} = ${4:param description}
///          ${5}}
///
/// ${6:Returns: ${7:return value}}
///
/// ${8:Throws:  ${9}Exception ${10}}
endsnippet

snippet Par "Params (Par)"
Params:  ${1:param} = ${2:param description}
///         ${3}
endsnippet

snippet Ret "Returns (Ret)"
Returns:  ${1:return value/s}
endsnippet

snippet Thr "Throws (Thr)"
Throws:  ${1}Exception ${2}
endsnippet

snippet Example "Examples (Example)"
Examples:
/// --------------------
/// ${1:example code}
/// --------------------
endsnippet
