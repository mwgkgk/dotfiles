snippet / *d(a)?(te)?/ "Date" rb
// `date-utc` //

${0}
endsnippet

snippet i "import" b
const ${1:std} = @import("${2:$1}")$3;
endsnippet

snippet f "f" b
fn ${2:celebrate}($3) ${4:!void} {
	${VISUAL}$5
}
endsnippet

snippet pf "pf" b
pub fn ${2:celebrate}($3) ${4:!void} {
	${VISUAL}$5
}
endsnippet

snippet main "main" b
pub fn main() ${1:!void} {
	${VISUAL}$2
}
endsnippet

snippet { "{" w
{
	${VISUAL}$0
}
endsnippet

# VISUAL is pointless here: this is for when Zig autoformats the closed bracket
# on write.
snippet {} "{}" w
{
	${VISUAL}$0
}
endsnippet

snippet / "/" w
// ${VISUAL}$1
endsnippet

snippet c "const" b
const ${1:stdout} = ${2:std.io.getStdOut().outStream()};
endsnippet

snippet r "try" w
try $0
endsnippet

snippet w "warn" w
std.debug.warn("${2:$1: \{\}}", .{${1:x}});
endsnippet

snippet t "test" b
test "$1" {
	$2
}
endsnippet

snippet as "assert" b
std.debug.assert($1);
endsnippet

snippet n "null" w
null
endsnippet

snippet e "==" w
== 
endsnippet

snippet ne "!=" w
!= 
endsnippet

# Not yet sure if this comes into play.
snippet nen "!= null" w
!= null
endsnippet

snippet ae "anyerror" w
anyerror
endsnippet

snippet er "error" w
error.${1:ArgNotFound}
endsnippet

snippet if "if" w
if ($1) {
	$2${VISUAL}
}
endsnippet

priority -3

snippet  /([\!:\w=-]+)/ "expand-any-word" rw
`!p
if match.group(0) is not None:
	snip.rv = match.group(0)`($1);
endsnippet
