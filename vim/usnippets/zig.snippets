snippet /d(a)?(te)?/ "Date" rb
// `date-utc` //
$0
endsnippet

snippet dd "dd-comment" b
// `!v system('date-jiv | tr -d "\n"')` ${0}
endsnippet

snippet dd "dd-inline" w
`!v system('date-jiv | tr -d "\n"')` ${0}
endsnippet

snippet i "import" b
const ${1:std} = @import("${2:$1}")$3;
endsnippet

snippet std "std" b
const std = @import("std");
endsnippet

snippet f "f" b
fn ${2:celebrate}($3) ${4:!void} {
	${VISUAL}$5
}
endsnippet

snippet pf "pf" b
pub fn ${2:celebrate}($3) ${4:!void} {
	${VISUAL}$5
}
endsnippet

snippet main "main" b
pub fn main() ${1:!void} {
	${VISUAL}$2
}
endsnippet

snippet { "{" w
{
	${VISUAL}$0
endsnippet

# VISUAL is pointless here: this is for when Zig autoformats the closed bracket
# on write.
snippet {} "{}" w
{
	${VISUAL}$0
}
endsnippet

snippet / "/" w
// ${VISUAL}$1
endsnippet

snippet c "const" b
const ${1:stdout} = ${2:std.io.getStdOut().outStream()};
endsnippet

snippet v "var" b
var ${1:i}: ${2:i32} = ${3:0};
endsnippet

snippet r "try" w
try $0
endsnippet

snippet re "return" w
return$0
endsnippet

snippet p "warn" w
std.debug.warn("\n${2:$1 == \{\}}\n", .{${1:x}});
endsnippet

snippet t "test" b
test "$1" {
	${VISUAL}$2
}
endsnippet

snippet b "basement" b
test "${3:BASEMENT/`date-jiv`}" {
	${VISUAL}$2
}
endsnippet

snippet as "assert" b
std.debug.assert($1);
endsnippet

snippet ae "assert equals" b
std.debug.assert(${1:err} == ${2:0);}
endsnippet

snippet ex "expect" b
std.testing.expect($1);
endsnippet

snippet ee "expect equals" b
std.testing.expect(${1:err} == ${2:0});
endsnippet

snippet n "null" w
null
endsnippet

snippet e "==" w
== 
endsnippet

snippet ne "!=" w
!= 
endsnippet

# Not yet sure if this comes into play.
snippet nen "!= null" w
!= null
endsnippet

snippet le "<=" w
<= 
endsnippet

snippet ge ">=" w
>= 
endsnippet

snippet ii "+=" w
+= 
endsnippet

snippet aer "anyerror" w
anyerror
endsnippet

snippet er "error" w
error.${1:ArgNotFound}
endsnippet

snippet ca "catch" w
catch |err| {
	${VISUAL}$1
}
endsnippet

snippet if "if" w
if ($1) {
	${VISUAL}$2
}
endsnippet

snippet else "else" w
else {
	${VISUAL}$1
}
endsnippet

snippet sw "switch" w
switch (${1:x}) {
	${2:1} => ${3:$1},
	else => ${4:$1},
}
endsnippet

snippet sc "switch clause" b
${1:else} => ${2:0},
endsnippet

snippet for "for" b
for (${1:xs}) |${2:x}| {
	${VISUAL}$3
}
endsnippet

snippet w "while" w
while ($1) {
	${VISUAL}$2
}
endsnippet

snippet w: "while-with-continue" w
while ($1) : ($2) {
	${VISUAL}$2
}
endsnippet

snippet to "@TypeOf" w
@TypeOf(${VISUAL}$1)$2
endsnippet

priority -3

snippet  /^\s+([\!:\w=-]+)$/ "expand-any-word-endline" rw
`!p
if match.group(0) is not None:
	snip.rv = match.group(0)`($1);
endsnippet

priority -4

snippet  /([\!:\w=-]+)/ "expand-any-word" rw
`!p
if match.group(0) is not None:
	snip.rv = match.group(0)`($1)
endsnippet
