# ||
# || Date
# ||

snippet /^ *d(a)?(te)?/ "Date" rb
// `date-utc`
$0
endsnippet

# TODO do this on empty line
snippet da "implicit-dam-file-start" "snip.line == 0" e
// `date-utc`

const std = @import("std")

pub fn main() void {
	${VISUAL}$0
}
endsnippet

snippet dd "dd-comment" b
// `!v system('date-jiv | tr -d "\n"')` ${VISUAL}$0
endsnippet

priority -1

snippet dd "dd-inline" w
`!v system('date-jiv | tr -d "\n"')` ${VISUAL}$0
endsnippet

priority 0

snippet dam "date, std, and main" b
// `date-utc`

const std = @import("std")

pub fn main() void {
	${VISUAL}$0
}
endsnippet

snippet dat "date and test" b
// `date-utc`

const std = @import("std")

test "$1" {
	${VISUAL}$0
}
endsnippet

# ||
# || Imports
# ||

snippet i "import" b
const ${1:std} = @import("${2:$1}")$0;
endsnippet

snippet ip "import std.debug.print" w
const print = std.debug.print;
endsnippet

snippet ia "import std.debug.assert" w
const assert = std.debug.assert;
endsnippet

snippet im "import std.mem" w
const mem = @import("std").mem;
endsnippet

snippet std "std" b
const std = @import("std");
endsnippet

# ||
# || Types
# ||

snippet to "@TypeOf" w
@TypeOf(${VISUAL}$1)$0
endsnippet

snippet as "as" w
@as(${1:i32}, ${VISUAL}$0)
endsnippet

# ||
# || Consts & Vars
# ||

snippet /(const|cons|con|co|c)/ "const" br
const ${1:x} = ${0:undefined};
endsnippet

snippet /(var|va|v)/ "var" br
var ${1:${2:i}: ${3:i32}} = ${0:0};
endsnippet

# ||
# || Structs
# ||

snippet s "struct" b
const ${1:Vec2} = struct{
	${2:x}: ${3:f64}$0
};
endsnippet

# ||
# || Functions
# ||

snippet f "f" b
fn ${2:function_name}($3) ${4:!void} {
	${VISUAL}$0
}
endsnippet

snippet pf "pf" b
pub fn ${2:function_name}($3) ${4:!void} {
	${VISUAL}$0
}
endsnippet

snippet main "main" b
pub fn main() void {
	${VISUAL}$0
}
endsnippet

snippet r "return" w
return ${VISUAL}$0
endsnippet

# ||
# || Errors
# ||

snippet t "try" w
try ${VISUAL}$0
endsnippet

snippet aer "anyerror" w
anyerror
endsnippet

snippet er "error" w
error.${1:ArgNotFound}
endsnippet

snippet ca "catch" w
catch |err| {
	${VISUAL}$0
}
endsnippet

# ||
# || Testing
# ||

snippet test "test" b
test "$1" {
	${VISUAL}$0
}
endsnippet

snippet /^$/ "test-implicit" r
test "${1:BASEMENT/`date-jiv`}" {
	${VISUAL}$0
}
endsnippet

snippet a "assert" b
assert(${VISUAL}$0);
endsnippet

snippet ae "assert equals" b
assert(${1:err} == ${0:0});
endsnippet

snippet ex "expect" b
std.testing.expect(${VISUAL}$0);
endsnippet

snippet ee "expect equals" b
std.testing.expect(${1:err} == ${0:0});
endsnippet

# ||
# || Control flow
# ||

snippet if "if" w
if ($1) {
	${VISUAL}$0
}
endsnippet

snippet else "else" w
else {
	${VISUAL}$0
}
endsnippet

snippet sw "switch" b
switch (${1:x}) {
	${2:1} => ${3:$1},
	else => ${0:unreachable},
}
endsnippet

priority -1

snippet sw "switch-inline" w
switch (${1:x}) {
	${2:1} => ${3:$1},
	else => ${0:unreachable},
};
endsnippet

priority 0

snippet sc "switch clause" b
${1:else} => ${0:unreachable},
endsnippet

snippet for "for" b
for (${1:xs}) |${2:x}| {
	${VISUAL}$0
}
endsnippet

snippet w "while" w
while ($1) {
	${VISUAL}$0
}
endsnippet

snippet w: "while-with-continue" w
while ($1) : ($2) {
	${VISUAL}$0
}
endsnippet

# ||
# || Predicates and shit
# ||

snippet n "null" w
null
endsnippet

snippet e "==" w
== 
endsnippet

snippet ne "!=" w
!= 
endsnippet

# Not yet sure if this comes into play.
snippet nen "!= null" w
!= null
endsnippet

snippet le "<=" w
<= 
endsnippet

snippet ge ">=" w
>= 
endsnippet

snippet ii "+=" w
+= 
endsnippet

# ||
# || Printing
# ||

snippet w "warn" w
std.debug.warn("\n${0:$1 == \{s\}}\n", .{${1:x}});
endsnippet

snippet p "print" w
print("\n${0:$1 == \{s\}}\n", .{${1:x}});
endsnippet

# ||
# || Blocks
# ||

snippet { "{" w
{
	${VISUAL}$0
endsnippet

# VISUAL is pointless here: this is for when Zig autoformats the closed bracket
# on write.
snippet {} "{}" w
{
	${VISUAL}$0
}
endsnippet

# ||
# || Comments
# ||

snippet / "comment-/" w
// ${VISUAL}$0
endsnippet

# Not worth my time to fuck with this regex right now
snippet // "comment-//" w
// ${VISUAL}$0
endsnippet

snippet ; "comment-generic" w
// ${VISUAL}$0
endsnippet

# ||
# || Fallbacks
# ||

priority -2

snippet  /;$/ "expand-any-endline-semicolon" rw
; // $0
endsnippet

priority -3

snippet  /^\s+([\!:\w=-]+)$/ "expand-any-word-endline" rw
`!p
if match.group(0) is not None:
	snip.rv = match.group(0)`($0);
endsnippet

priority -4

snippet  /([\!:\w=-]+)/ "expand-any-word" rw
`!p
if match.group(0) is not None:
	snip.rv = match.group(0)`($0)
endsnippet
