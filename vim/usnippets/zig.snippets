# ||
# || Date
# ||

snippet /^ *da(te)?/ "Date" rb
// `date-utc`
$0
endsnippet

# TODO do this on empty line
snippet da "implicit-dam-file-start" "snip.line == 0" e
// `date-utc`

const std = @import("std");
const print = std.debug.print;

pub fn main() void {
	${VISUAL}$0
}
endsnippet

snippet dd "dd-comment" b
// `!v system('date-jiv | tr -d "\n"')` ${VISUAL}$0
endsnippet

priority -1

snippet dd "dd-inline" w
`!v system('date-jiv | tr -d "\n"')` ${VISUAL}$0
endsnippet

priority 0

snippet dam "date, std, and main" b
// `date-utc`

const std = @import("std")

pub fn main() void {
	${VISUAL}$0
}
endsnippet

snippet dat "date and test" b
// `date-utc`

const std = @import("std")

test "$1" {
	${VISUAL}$0
}
endsnippet

# ||
# || Imports
# ||

snippet i "import" b
const ${1:std} = @import("${2:$1}")$0;
endsnippet

snippet ip "import std.debug.print" w
const print = std.debug.print;
endsnippet

snippet ia "import std.debug.assert" w
const assert = std.debug.assert;
endsnippet

snippet ie "import std.testing.expect" w
const expect = std.testing.expect;
endsnippet

snippet im "import std.mem" w
const mem = @import("std").mem;
endsnippet

snippet std "std" b
const std = @import("std");
endsnippet

# ||
# || Types
# ||

snippet to "@TypeOf" w
@TypeOf(${VISUAL}$1)$0
endsnippet

snippet as "as" w
@as(${1:i32}, ${VISUAL}$0)
endsnippet

# ||
# || Consts & Vars
# ||

snippet /(const|cons|con|co|c)/ "const" br
const ${1:x} = ${0:undefined};
endsnippet

snippet /(var|va|v)/ "var" br
var ${1:${2:i}: ${3:i32}} = ${0:0};
endsnippet

# ||
# || Enums
# ||

snippet e "enum" w
enum { ${VISUAL}$0 }
endsnippet

# ||
# || Structs
# ||

snippet s "struct" b
const ${1:Vec2} = struct{
	${2:x}: ${3:f64}$0
};
endsnippet

# ||
# || Functions
# ||

snippet f "f" b
fn ${2:function_name}($3) ${4:!void} {
	${VISUAL}$0
}
endsnippet

snippet ff "pub fn" b
pub fn ${2:function_name}($3) ${4:!void} {
	${VISUAL}$0
}
endsnippet

snippet main "main" b
pub fn main() void {
	${VISUAL}$0
}
endsnippet

snippet r "return" w
return ${VISUAL}$0
endsnippet

# ||
# || Errors
# ||

# snippet /^(\s+)$/ "try" r
# `!p
# if match.group(1) is not None:
#     snip.rv = match.group(1)`try ${VISUAL}$0
# endsnippet

snippet aer "anyerror" w
anyerror
endsnippet

snippet er "error" w
error.${1:ArgNotFound}
endsnippet

snippet ca "catch" w
catch |err| {
	${VISUAL}$0
}
endsnippet

snippet oe "orelse" w
orelse ${VISUAL}$0
endsnippet

# ||
# || Defer
# ||

snippet df "defer" w
defer
endsnippet

snippet edf "errdefer" w
errdefer
endsnippet

# ||
# || Testing
# ||

snippet t "test" b
test "$1" {
	${VISUAL}$0
}
endsnippet

# If line above is empty, test:
# snippet /^$/ "test-implicit" "re.match('^$', snip.buffer[snip.line-1])" re
# test "${1:BASEMENT/`date-jiv`}" {
# 	${VISUAL}$0
# }
# endsnippet

snippet a "assert" b
assert(${VISUAL}$0);
endsnippet

snippet ae "assert equals" b
assert(${1:err} == ${0:0});
endsnippet

snippet /\b(te|ex)/ "try expect" wr
try expect(${VISUAL}$0);
endsnippet

snippet ee "expect equals" b
expect(${1:err} == ${0:0});
endsnippet

# ||
# || Control flow
# ||

snippet if "if" w
if ($1) {
	${VISUAL}$2
}$0
endsnippet

snippet } "else" w
} else {
	${VISUAL}$0
}
endsnippet

snippet sw "switch" b
switch (${1:x}) {
	${2:1} => ${3:$1},
	else => ${0:unreachable},
}
endsnippet

priority -1

snippet sw "switch-inline" w
switch (${1:x}) {
	${2:1} => ${3:$1},
	else => ${0:unreachable},
};
endsnippet

priority 0

snippet sc "switch clause" b
${1:else} => ${0:unreachable},
endsnippet

snippet /\b(for|fo)/ "for" r
for (${1:xs}) |${2:x}| {
	${VISUAL}$0
}
endsnippet

snippet w "while" w
while ($1) {
	${VISUAL}$0
}
endsnippet

snippet w: "while-with-continue" w
while ($1) : ($2) {
	${VISUAL}$0
}
endsnippet

# ||
# || Arrows
# ||

snippet = "=>" b
${1:else} => ${0:unreachable},
endsnippet

priority -1

snippet = "inline =>" w
=> ${0:unreachable},
endsnippet

priority 0

# ||
# || Predicates
# ||

snippet n "null" w
null
endsnippet

snippet unr "unreachable" w
unreachable
endsnippet

snippet eq "==" w
== 
endsnippet

snippet ne "!=" w
!= 
endsnippet

# Not yet sure if this comes into play.
snippet nen "!= null" w
!= null
endsnippet

snippet le "<=" w
<= 
endsnippet

snippet ge ">=" w
>= 
endsnippet

snippet ii "+=" w
+= 
endsnippet

snippet eql "eql" w
mem.eql(${1:u8}, $2, ${VISUAL}$0)
endsnippet

# ||
# || Printing
# ||

snippet w "warn" w
std.debug.warn("${0:$1 == \{s\}}\n", .{${1:x}});
endsnippet

snippet p "print" w
print("$1", .{${0:${VISUAL}}});
endsnippet

snippet sp "stdout.print" w
stdout.print("$1", .{${0:${VISUAL}});
endsnippet

snippet sr "stdin.readUntilDelimiterOrEof" w
var buf: [10]u8 = undefined;

if (try stdin.readUntilDelimiterOrEof(buf[0..], '\n')) |user_input| {
	return 1;
} else {
	return 1;
}
endsnippet

snippet /\b(stdout|stdo|so)/ "stdout" rw
const stdout = std.io.getStdOut().writer();
endsnippet

snippet stdin "stdin" w
const stdin = std.io.getStdIn().reader();
endsnippet

# ||
# || Blocks
# ||

snippet { "{" w
{
	${VISUAL}$0
}
endsnippet

# VISUAL is pointless here: this is for when Zig autoformats the closed bracket
# on write.
snippet {} "{}" w
{
	${VISUAL}$0
}
endsnippet

# ||
# || Comments
# ||

snippet / "comment-/" w
// ${VISUAL}$0
endsnippet

# Not worth my time to fuck with this regex right now
snippet // "comment-//" w
// ${VISUAL}$0
endsnippet

snippet ; "comment-generic" w
// ${VISUAL}$0
endsnippet

snippet /^(\s*)(// )?(T|td)/ "TODO-comment" r
`!p
# Whitespace:
if match.group(1) is not None:
    snip.rv = match.group(1)`// TODO ${VISUAL}$0
endsnippet

# ||
# || Fallbacks
# ||

priority -2

snippet  /;$/ "expand-any-endline-semicolon" rw
; // ${VISUAL}$0
endsnippet

priority -3

snippet  /^\s+([\!:\w=-]+)$/ "expand-any-word-endline" rw
`!p
if match.group(0) is not None:
	snip.rv = match.group(0)`(${VISUAL}$0);
endsnippet

priority -4

snippet  /([\!:\w=-]+)/ "expand-any-word" rw
`!p
if match.group(0) is not None:
	snip.rv = match.group(0)`(${VISUAL}$0)
endsnippet
