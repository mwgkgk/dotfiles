# TODO: handle the beginning-of-line whitespace and brackets as match group

snippet "^(\()?rq" "require" r
(require ${1:"asdf"}`!p
if match.group(1) is None:
	snip.rv = ")"`$2
endsnippet

snippet defsys "defsystem" b
(defsystem "${1:school}"
  :version "0.1.0"
  :depends-on (#:${2:find-port})

  :in-order-to ((test-op (test-op "$1-test")))

  :build-operation program-op
  :build-pathname "target/release/$1"
  :entry-point "$1::main"

  :components ((:module "src"
                :serial t 
                :components
                ((:file "package")
                 (:file "$1")))))

(defsystem "$1/debug"
  :version "0.1.0"
  :depends-on (#:${2:find-port})

  :in-order-to ((test-op (test-op "$1-test")))

  :build-operation program-op
  :build-pathname "target/debug/$1"
  :entry-point "$1::main"

  :components ((:module "src"
                :serial t 
                :components
                ((:file "package")
                 (:file "$1")))))
endsnippet

snippet defp "defp" w
(defparameter *$1*
	${2:nil})
endsnippet

snippet defv "defv" w
(defvar *$1*
	${2:nil})
endsnippet

snippet "(\()?f" "f" rw
(defun ${1:name} ($2)
	${3:nil}`!p
if match.group(1) is None:
	snip.rv = ")"`
endsnippet

snippet main "main" b
(defun main ()
	${1:nil})

#+nil
(progn
	(main$2))
endsnippet

snippet decl "decl " w
(declare (ignore ${1:args}))
endsnippet

snippet "(\()?\bm" "m" rw
(defmacro ${1:name} ($3${2:&body forms})
	${4:nil}`!p
if match.group(1) is None:
	snip.rv = ")"`
endsnippet

snippet "(\()?\bdo" "m" rw
(do ((${1:x} ${2:0} (${3:1+ x}))$4)
    (${5:end-condition} ${6:optional-exit-form})
  $7`!p
if match.group(1) is None:
	snip.rv = ")"`
endsnippet

snippet re "&rest" w
&rest ${1:forms}$2
endsnippet

snippet ba "basement" b
#+nil
(progn
	${VISUAL}${1:nil})
endsnippet

snippet ql "quickload" b
#+ql
(ql:quickload '(:${1:find-port}))
endsnippet

snippet at "at" b
#J
(at `date-jiv`
		${0})
endsnippet

snippet "(\()?cond" "cond" r
(cond
	((${1:equal x y}) ${2:nil})$3`!p
if match.group(1) is None:
	snip.rv = ")"`
endsnippet

snippet cc "cond clause" i
(${3:(${1:equal}$2)} $4)$5
endsnippet

snippet "(\()?let" "let" r
(let
	((${1:${VISUAL}} ${3:($2)})$4)
	${5:$1}`!p
if match.group(1) is None:
	snip.rv = ")"`
endsnippet

snippet "(\()?fle" "flet" wr
(flet
	((${1:x} ($2)
		${3:nil})$4)
	${5:nil}`!p
if match.group(1) is None:
	snip.rv = ")"`
endsnippet

snippet lc "let clause" i
(${1:x} ($2))$3
endsnippet

snippet "(\()?eq" "equal" wr
(equal $1`!p
if match.group(1) is None:
	snip.rv = ")"`
endsnippet

snippet "(\()?fmt" "format" wr
(format ${3:nil} "$1"$2`!p
if match.group(1) is None:
	snip.rv = ")"`
endsnippet

snippet "(\()?lo(op)?" "loop" wr
(loop
	${2::for }$1`!p
if match.group(1) is None:
	snip.rv = ")"`
endsnippet

snippet for "Loop for" w
:for ${1:x} ${2::across} ${3:str}
endsnippet

snippet col "Loop collect" w
:collect $1
endsnippet

snippet /:?fin(ally)?/ "Loop finally" rw
:finally (return ${2:($1)})
endsnippet

snippet ; ";" b
;;; ${VISUAL}$0
endsnippet

snippet / *d(a)?(te)?/ "Date" rb
;;; `date-utc` ;;;
${0}
endsnippet

snippet { "{" i
昂幛稚诱撂
endsnippet

snippet [ "[" i
[${0:a${VISUAL}}]
endsnippet

snippet ( "(" i
(${0:a${VISUAL}})
endsnippet


# StumpWM

snippet k "define-key-top" b
(define-key *top-map* (kbd "${1:s-k}") "${2:move-focus up}")
endsnippet

snippet kk "define-key" b
(define-key *${1:root}-map* (kbd "${2:k}") "${3:move-focus up}")
endsnippet

snippet kr "define-key-root" b
(define-key *root-map* (kbd "${1:k}") "${2:move-focus up}")
endsnippet

snippet sk "sparse-keymap" b
(defvar *${1:leader}-$2map*
  (let ((m (make-sparse-keymap)))
		$3
		m))
endsnippet

snippet km "sparse-keymap map" b
(define-key m (kbd "${1:k}") "${2:move-focus up}")
endsnippet

snippet cmd "defcommand" b
(defcommand ${1:cmd} (${2:arg})
	((:${3:shell} "${4:Enter shell command}:")$5)
	$6)
endsnippet

snippet defcl "defcl" b
(defclass ${1:bank-account} ($2)
  (${3:balance}))
endsnippet

snippet j "jiv" b
#+J
($1)
endsnippet

snippet dj "dj" b
;;; `date-utc` ;;;

#+J
($1)
endsnippet

snippet q "question" b
(question
  "$1"
  $2)
endsnippet

snippet nil "#+nil" b
#+nil
endsnippet

snippet ' "'" w
'(${VISUAL}$1)$2
endsnippet

snippet "(\()?\bp" "print" wr
(format ${4:t} "${3:${2:a}%}" ${1:${VISUAL}}`!p
if match.group(1) is None:
	snip.rv = ")"`
endsnippet

priority -2

snippet /^([\!:\w=-]+)/ "expand-any-word-b" br
#+J
(`!p
if match.group(0) is not None:
	snip.rv = match.group(0)` $1)
endsnippet

priority -3

snippet  /([\!:\w=-]+)/ "expand-any-word" rw
(`!p
if match.group(0) is not None:
	snip.rv = match.group(0)` $1)
endsnippet
