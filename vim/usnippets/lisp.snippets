# Imports & Packages

snippet "(\()?\bip" "in-package" rw
(in-package #:${VISUAL}${1:`!p
if not snip.v.text:
	snip.rv = "common-lisp-user"`}`!p
if match.group(1) is None:
	snip.rv = ")"`
endsnippet

snippet "^(\()?\brq" "require" rw
(require ${1:"asdf"}`!p
if match.group(1) is None:
	snip.rv = ")"`$2
endsnippet

snippet ql "quickload" b
#+ql
(progn
	(ql:quickload '(:${1:1am}))
	(use-package :$1))
endsnippet

snippet defsys "defsystem" b
(defsystem "${1:school}"
  :version "0.1.0"
  :depends-on (#:${2:find-port})

  :in-order-to ((test-op (test-op "$1-test")))

  :build-operation program-op
  :build-pathname "target/release/$1"
  :entry-point "$1::main"

  :components ((:module "src"
                :serial t 
                :components
                ((:file "package")
                 (:file "$1")))))

(defsystem "$1/debug"
  :version "0.1.0"
  :depends-on (#:${2:find-port})

  :in-order-to ((test-op (test-op "$1-test")))

  :build-operation program-op
  :build-pathname "target/debug/$1"
  :entry-point "$1::main"

  :components ((:module "src"
                :serial t 
                :components
                ((:file "package")
                 (:file "$1")))))
endsnippet

# Variables

snippet "(\()?\bdefp" "defparameter" rw
(defparameter *$1*
	${2:nil}`!p
if match.group(1) is None:
	snip.rv = ")"`
endsnippet

snippet "(\()?\bdefv" "defvar" rw
(defvar *$1*
	${2:nil}`!p
if match.group(1) is None:
	snip.rv = ")"`
endsnippet

snippet "(\()?\bdefc" "defconstant" rw
(defconstant +$1+
	${2:nil}`!p
if match.group(1) is None:
	snip.rv = ")"`
endsnippet

# Functions

snippet "(\()?\bf" "defun" rw
(defun ${1:name} ($2)
	${3:nil}`!p
if match.group(1) is None:
	snip.rv = ")"`
endsnippet

snippet re "&rest" w
&rest ${1:forms}$2
endsnippet

snippet opt "&optional" w
&optional ${1:form}$2
endsnippet

snippet main "main" b
(defun main ()
	${1:nil})

#+nil
(progn
	(main$2))
endsnippet

snippet decl "decl " w
(declare (ignore ${1:args}))
endsnippet

snippet "(\()?\bfmk" "fmk" rw
(fmakunbound '${1:name}`!p
if match.group(1) is None:
	snip.rv = ")"`
endsnippet

snippet l "lambda" w
#'(lambda (${1:x}) ${2:nil})
endsnippet

snippet /^$/ "basement-implicit" r
#+nil
(progn
	${VISUAL}${1:`!p
if not snip.v.text:
	snip.rv = "nil"`})
endsnippet

snippet /^e/ "basement-test" r
#+nil
(progn
	(e ${VISUAL}${1:`!p
if not snip.v.text:
	snip.rv = "nil"`}))
endsnippet

# Types

snippet "(\()?\bt" "deftype" rw
(deftype $1 (${2:&optional ${3:type}})
	\`${4:nil}`!p
if match.group(1) is None:
	snip.rv = ")"`
endsnippet

# Classes

snippet cl "defcl" b
(defclass ${1:bank-account} ($2)
  (${3:balance}$0))
endsnippet

snippet "(\()?\bmi" "make-instance" rw
(make-instance '${1:bank-account}`!p
if match.group(1) is None:
	snip.rv = ")"`
endsnippet

# Macros

snippet "(\()?\bm" "m" rw
(defmacro ${1:name} ($3${2:&body body})
	${4:nil}`!p
if match.group(1) is None:
	snip.rv = ")"`
endsnippet

snippet "(\()?\bdo" "do" rw
(do ((${1:x} ${2:0} (${3:1+ x}))$4)
	(${5:end-condition} ${6:optional-exit-form})
  $7`!p
if match.group(1) is None:
	snip.rv = ")"`
endsnippet

# Cond Macro

snippet "(\()?\bcond" "cond" r
(cond
	((${1:equal x y}) ${2:nil})$3`!p
if match.group(1) is None:
	snip.rv = ")"`
endsnippet

snippet cc "cond clause" w
(${3:(${1:equal}$2)} $4)$5
endsnippet

# Case Macro

snippet "(\()?\bcase" "case" rw
(case $1
	($2)
	${4:(otherwise ${3:nil})}`!p
if match.group(1) is None:
	snip.rv = ")"`
endsnippet

# Let, Flet, Labels

snippet "(\()?\blet" "let" wr
(let
	(($1 ${3:(${2:${VISUAL}})})$4)
	${5:$1}`!p
if match.group(1) is None:
	snip.rv = ")"`
endsnippet

snippet "(\()?\bflet|letf" "flet" wr
(flet
	((${1:x} ($2)
		${3:nil})$4)
	$5`!p
if match.group(1) is None:
	snip.rv = ")"`
endsnippet

snippet "(\()?\blab" "labels" wr
(labels
	((${1:x} ($2)
		${3:nil})$4)
	${5:nil}`!p
if match.group(1) is None:
	snip.rv = ")"`
endsnippet

snippet lc "let clause" w
(${1:x} ($2))$3
endsnippet

# Format

snippet "(\()?\bfmt" "format" wr
(format ${3:nil} "$1"$2`!p
if match.group(1) is None:
	snip.rv = ")"`
endsnippet

snippet "(\()?\bp" "print" wr
(format ${4:t} "${3:${2:~a}~%}" ${1:${VISUAL}}`!p
if match.group(1) is None:
	snip.rv = ")"`
endsnippet

snippet { "{" i
~{${0:~a${VISUAL}}~}
endsnippet

snippet [ "[" i
~[${0:~a${VISUAL}}~]
endsnippet

snippet ( "(" i
~(${0:~a${VISUAL}}~)
endsnippet

# Loop Facility

snippet "(\()?\blo(op)?" "loop" wr
(loop
	${2::for }$1`!p
if match.group(1) is None:
	snip.rv = ")"`
endsnippet

snippet for "Loop for" w
:for ${1:x} ${2::across} ${3:str}
endsnippet

snippet col "Loop collect" w
:collect $1
endsnippet

snippet /:?fin(ally)?/ "Loop finally" rw
:finally (return ${2:($1)})
endsnippet

# Higher Order Functions

snippet "(\()?\bfc" "funcall" wr
(funcall $1`!p
if match.group(1) is None:
	snip.rv = ")"`
endsnippet

snippet "(\()?\bri" "remove-if" rw
(remove-if ${3:#'nullp}$2 ${1:nil}`!p
if match.group(1) is None:
	snip.rv = ")"`
endsnippet

snippet "(\()?\brin" "remove-if-not" rw
(remove-if-not ${3:#'nullp}$2 ${1:nil}`!p
if match.group(1) is None:
	snip.rv = ")"`
endsnippet

# Predicates

snippet "(\()?\beq" "equal" wr
(equal $1`!p
if match.group(1) is None:
	snip.rv = ")"`
endsnippet

snippet "(\()?\bep" "equalp" wr
(equalp $1`!p
if match.group(1) is None:
	snip.rv = ")"`
endsnippet

# Quotes

snippet ' "'" w
'(${VISUAL}$1)$2
endsnippet

snippet ` "`" w
\`(${VISUAL}$1)$2
endsnippet

# Bits and Pieces

snippet /^;?;?;/ ";;;" r
;;; ${VISUAL}$0
endsnippet

snippet /^(\s+);/ ";;" r
`!p
if match.group(1) is not None:
    snip.rv = match.group(1)`;; ${VISUAL}$0
endsnippet

snippet / *d(a)?(te)?/ "Date" rb
;;; `date-utc` ;;;
${0}
endsnippet

snippet nil "#+nil" b
#+nil
endsnippet

snippet #+nil "#+nil continued" b
#+nil
($0)
endsnippet

snippet im "doing my part" b
"I'm doing my part!"
endsnippet

# 1am

snippet ro "rooftops" b
#+nil
(progn
	(1am:test ${1:test-name}
		${VISUAL}${3:(is ${2:nil})})
	(1am:run '($1)))
endsnippet

# Jiv-within-CL, because it sometimes be like that

snippet j "jiv" b
#+J
($1)
endsnippet

snippet dj "dj" b
;;; `date-utc` ;;;

#+J
($1)
endsnippet

snippet at "at" b
#J
(at `date-jiv`
		${0})
endsnippet

snippet q "question" b
(question
  "$1"
  $2)
endsnippet

# Fallbacks

priority -2

snippet /^([\!:\w=-]+)/ "expand-any-word-b" br
#+J
(`!p
if match.group(0) is not None:
	snip.rv = match.group(0)` $1)
endsnippet

priority -3

snippet  /([\!:\w=-]+)/ "expand-any-word" rw
(`!p
if match.group(0) is not None:
	snip.rv = match.group(0)` $1)
endsnippet
