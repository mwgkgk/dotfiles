# ||
# || Modules
# ||

snippet u "use" w
use $0;
endsnippet

snippet utf "utf" w
use utf8;
use open ":std", ":encoding(UTF-8)";
endsnippet

# ||
# || Date
# ||

snippet /^ *da(te)?/ "Date" rb
# `date-utc`
${0}
endsnippet

snippet da "date-file-start" "snip.line == 0" e
#!/usr/bin/env perl

use v5.10;
use strict;
use warnings;

# `date-utc`

$0
endsnippet

snippet dd "dd-inline" w
`!v system('date-jiv | tr -d "\n"')` ${VISUAL}$0
endsnippet

# ||
# || Comments
# ||

snippet ; "comment-generic" w
# ${VISUAL}$0
endsnippet

snippet \ "comment-forth" w
# ${VISUAL}$0
endsnippet

snippet # "comment-#" w
# ${VISUAL}$0
endsnippet

snippet /^(\s*)(// )?(T|td)/ "TODO-comment" r
`!p
# Whitespace:
if match.group(1) is not None:
	snip.rv = match.group(1)`# TODO ${VISUAL}$0
endsnippet

snippet /^$/ "basement-implicit" "snip.line > 0 and re.match('^$', snip.buffer[snip.line-1])" re
=begin comment `date-jiv`

${VISUAL}$0

=end comment
=cut
endsnippet

# ||
# || Print
# ||

snippet /\b(say|sa|s)/ "say" r
say "${VISUAL}$0";
endsnippet

snippet p "say minus quotes" w
say ${VISUAL}$0;
endsnippet

snippet pr "print" w
print ${VISUAL}$0;
endsnippet

snippet /\b(chomp|chom|cho)/ "chomp" wr
chomp(${VISUAL}$0);
endsnippet

# ||
# || Standard I/O
# ||

snippet si "<STDIN>" w
<STDIN>
endsnippet

# ||
# || Subroutines
# ||

snippet f "sub"
sub $1 {
	${VISUAL}$0
}
endsnippet

snippet r "return" w
return ${VISUAL}$0
endsnippet

# ||
# || Loops
# ||

snippet for "for"
for (my $${1:var} = 0; $$1 < ${2:expression}; $$1++) {
	${VISUAL}$0
}
endsnippet

snippet fore "foreach"
foreach$1 (@${2:array}) {
	${VISUAL}$0
}
endsnippet

# ||
# || Control flow
# ||

snippet if "if"
if ($1) {
	${VISUAL}$0
}
endsnippet

snippet } "} else" w
} else {
	${VISUAL}$0
}
endsnippet

snippet unless "unless"
unless ($1) {
	${VISUAL}$0
}
endsnippet

snippet while "while"
while ($1) {
	${VISUAL}$0
}
endsnippet

# ||
# || Variables
# ||

snippet /\b(my|m)/ "my" r
my $$1 = ${VISUAL}$0;
endsnippet

snippet $ "$variable" w
my $$1 = ${VISUAL}$0;
endsnippet

snippet @ "@array" w
my @$1 = ${VISUAL}$0;
endsnippet

snippet % "%hash" w
my %$1 = ${VISUAL}$0;
endsnippet

# ||
# || Processes
# ||

snippet ` "``" w
`${VISUAL}$0`
endsnippet

# ||
# || Fallback
# ||

priority -2

snippet  /;$/ "expand-endline-semicolon" rw
; # ${VISUAL}$0
endsnippet

snippet /([:\w]+)\$/ "expand-any-word-as-scalar" r
$`!p
if match.group(1) is not None:
	snip.rv = match.group(1)` $0
endsnippet

snippet /([:\w]+)@/ "expand-any-word-as-array" r
@`!p
if match.group(1) is not None:
	snip.rv = match.group(1)` $0
endsnippet

priority -3

snippet  /^\s+([:\w]+)$/ "expand-any-word-endline" rw
`!p
if match.group(0) is not None:
	snip.rv = match.group(0)`(${VISUAL}$0);
endsnippet

priority -4

snippet  /([:\w]+)/ "expand-any-word" rw
`!p
if match.group(0) is not None:
	snip.rv = match.group(0)`(${VISUAL}$0)
endsnippet
