# ||
# || Date
# ||

snippet /d(a)?(te)?/ "Date" rb
// `date-utc` //
$0
endsnippet

snippet dd "dd-comment" b
// `!v system('date-jiv | tr -d "\n"')` ${0}
endsnippet
priority -1

snippet dd "dd-inline" w
`!v system('date-jiv | tr -d "\n"')` ${0}
endsnippet

priority 0

# ||
# || Packages
# ||

snippet i "import" b
import (
	"${1:fmt}"$2
)$3
endsnippet

snippet /^p/ "package" r
package ${1:main}
endsnippet

snippet pm "package main" b
package main

import "log"

func main() {
	${1:log.Fatal(${2:"${3:${4:Under construction}!}"})}
}
endsnippet

# ||
# || Type
# ||

snippet ty "type" b
type ${1:Writer} ${2:${3:interface}} {
	${4:${5:Write}(${6:p []byte}) (${7:${8:n int}, err error})}
}
endsnippet

snippet tf "function declaration" b
${5:Read}(${6:p []byte}) (${7:${8:n int}, err error})
endsnippet

# ||
# || Const
# ||

snippet let "const" w
const ${1:listenAddr}${2/(.+)/ /}${2:string} = ${0:"localhost:8153"}
endsnippet

snippet lets "consts" w
const (
	${1:constant}${2/(.+)/ /}${2:type} = ${0:value}
)
endsnippet

snippet iota "Iota constant generator" b
const (
	${1:constant}${2/(.+)/ /}${2:type} = iota
)
endsnippet

# ||
# || Var
# ||

snippet var "Variable declaration" b
var ${1:name}${2/(.+)/ /}${2:type}${3: = ${0:value}}
endsnippet

snippet vars "Variables declaration" b
var (
	${1:name}${2/(.+)/ /}${2:type}${3: = ${0:value} }
)
endsnippet

# ||
# || Functions
# ||

snippet f "function" b
func ${1:name}(${2:x int})${3/(.+)/ /}${3:int} {
	return ${0:${VISUAL}}
}
endsnippet

priority -1

snippet f "anonymous function" w
func(${2:x int})${3/(.+)/ /}${3:int} {
	return ${0:${VISUAL}}
}
endsnippet

priority 0

snippet main "main" b
func main() {
	${0:${VISUAL}}
}
endsnippet

snippet m "Method" b
func (${1:receiver} ${2:type}) ${3:name}(${4:params})${5/(.+)/ /}${5:type} {
	return ${0:${VISUAL}}
}
endsnippet

snippet r "return" w
return $1
endsnippet

# ||
# || Control Flow
# ||

snippet fo "For loop with no arg (while loop)" b
for {
	${VISUAL}$1
}
endsnippet

snippet for "For loop" b
for ${1:condition}${1/(.+)/ /}{
	${0:${VISUAL}}
}
endsnippet

snippet forr "For range loop" b
for ${2:name} := range ${1:collection} {
	${0:${VISUAL}}
}
endsnippet

snippet if "If statement" b
if ${1:condition}${1/(.+)/ /}{
	${0:${VISUAL}}
}
endsnippet

snippet } "else" w
} else {
	${VISUAL}$1
}$2
endsnippet

snippet switch "Switch statement" b
switch ${1:expression}${1/(.+)/ /}{
case${0}
}
endsnippet

snippet c "Case clause" b
case ${1:condition}:
	${0:${VISUAL}}
endsnippet

snippet default "Default clause" b
default:
	${0:${VISUAL}}
endsnippet

snippet sel "select" w
select {
	case $1:
		$2
}
endsnippet

# ||
# || Errors
# ||

snippet de "defer" w
defer ${1:log.Fatal(${2:"${3:${4:Under construction}!}"})}
endsnippet

snippet uc "defer under-construction" w
defer log.Fatal("Under construction!")
endsnippet


snippet U "Under construction!" w
Under construction!
endsnippet

snippet ie "if err != nil" b
if err != nil {
	${1:log.Fatal(${2:err})}
}$5
endsnippet

snippet lf "log.Fatal" w
log.Fatal(${2:"${3:${4:Under construction}!}"})
endsnippet

# ||
# || Printing
# ||

priority -1

snippet s "fmt.Println" w
fmt.Println(${3:"$1"}$2)$4
endsnippet

priority 0

snippet /^(\s)+p/ "fmt.Fprintln name, type, value" r
`!p
if match.group(1) is not None:
    snip.rv = match.group(1)`fmt.Fprintln("var $1 %T = %v", ${1:${VISUAL}}, $1)
endsnippet

snippet e "fmt.Fprintln to stderr" w
fmt.Fprintln(os.Stderr, "$1")
endsnippet

# ||
# || Time
# ||

snippet sl "sleep" w
time.Sleep(${1:${2:500} * ${3:time.Millisecond}})
endsnippet

snippet sec "sec" w
time.Second
endsnippet

snippet ms "ms" w
time.Millisecond
endsnippet

# ||
# || Bits & pieces
# ||

snippet /^(\s)+;/ "double-edged :=" r
`!p
if match.group(1) is not None:
    snip.rv = match.group(1)`$1 := $2
endsnippet

priority -1

snippet ; ":=" w
:= 
endsnippet

priority 0

snippet / "//" w
// $0
endsnippet

snippet { "{" w
{
	${VISUAL}$0

endsnippet

# ||
# || Fallbacks
# ||

priority -3

snippet  /([\!:\w=-]+),/ "expand-any-word-comma-err-:=" rw
`!p
if match.group(0) is not None:
	snip.rv = match.group(0)` err := ${1:nil, nil}
endsnippet

priority -4

snippet  /([\!:\w=-]+)/ "expand-any-word" rw
`!p
if match.group(0) is not None:
	snip.rv = match.group(0)`($1)
endsnippet
